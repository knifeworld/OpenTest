#include <iostream>
#include <chrono>
#include <string>
using namespace std;
#include <stdio.h>
#include <Windows.h>
#include "messager.h"

int ConScreenWidth = 120; //X (columns)
int ConScreenHeight = 40; //Y (rows)
int ConMapWidth = 16;
int ConMapHeight = 16;

float fPlayerX = 8.5f;
float fPlayerY = 8.5f;
float fPlayerAngle = 0.0f;
float fFOV = 3.14159f / 4.0f;
float fDepth = 15.0f;


int main(int argc, char* argv[])
{
	bool running = false;
	waitmessage("Ready!");

	/*Create Screen Buffer*/

	// reference for size of widechar
	//size_t wcslen(const wchar_t *s);
	wchar_t *screen = new wchar_t[ConScreenWidth * ConScreenHeight];
	HANDLE hConsole = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE, 0, NULL, CONSOLE_TEXTMODE_BUFFER, NULL);
	SetConsoleActiveScreenBuffer(hConsole);
	DWORD dwBytesWritten = 0;

	wstring map;
	map += L"################";
	map += L"#..............#";
	map += L"#..............#";
	map += L"#.......########";
	map += L"#..............#";
	map += L"#....#.........#";
	map += L"#..............#";
	map += L"#..............#";
	map += L"#........#.....#";
	map += L"#........#.....#";
	map += L"######...#.....#";
	map += L"#........#.....#";
	map += L"#........#.....#";
	map += L"#........#.....#";
	map += L"#........#.....#";
	map += L"################";

	auto tp1 = chrono::system_clock::now();
	auto tp2 = chrono::system_clock::now();

	running = true;
	while (running)
	{
		tp2 = chrono::system_clock::now();
		chrono::duration<float> elapsedTime = tp2 - tp1;
		tp1 = tp2;
		float fElapsedTime = elapsedTime.count();

		if (GetAsyncKeyState((unsigned short)'A') & 0x8000)
			fPlayerAngle -= (2.2f) * fElapsedTime;

		if (GetAsyncKeyState((unsigned short)'D') & 0x8000)
			fPlayerAngle += (2.2f) * fElapsedTime;

		if (GetAsyncKeyState((unsigned short)'W') & 0x8000)
		{
			fPlayerX += sinf(fPlayerAngle) * 4.0f * fElapsedTime;
			fPlayerY += cosf(fPlayerAngle) * 4.0f * fElapsedTime;
		}

		if (GetAsyncKeyState((unsigned short)'S') & 0x8000)
		{
			fPlayerX -= sinf(fPlayerAngle) * 4.0f * fElapsedTime;
			fPlayerY -= cosf(fPlayerAngle) * 4.0f * fElapsedTime;
		}

		for (int x = 0; x < ConScreenWidth; x++)
		{
			float fRayAngle = (fPlayerAngle - fFOV / 2.0f) + ((float)x / (float)ConScreenWidth) * fFOV;

			float fDistanceToWall = 0.0f;
			bool bHitWall = false;

			float fEyeX = sinf(fRayAngle);
			float fEyeY = cosf(fRayAngle);

			while (!bHitWall && fDistanceToWall < fDepth)
			{
				fDistanceToWall += 0.05f;

				if (fDistanceToWall > fDepth)
					fDistanceToWall = 15.0f;

				int TestX = (int)(fPlayerX + fEyeX * fDistanceToWall);
				int TestY = (int)(fPlayerY + fEyeY * fDistanceToWall);

				if (TestX < 0 || TestX >= ConMapWidth || TestY < 0 || TestY >= ConMapHeight)
				{
					bHitWall = true;
					fDistanceToWall = fDepth;
				}
				else
				{
					if (map.c_str()[TestY * ConMapWidth + TestX] == '#')
						bHitWall = true;
				}
			}

			float nCeiling_f = (float)(ConScreenHeight / 2.0) - ConScreenHeight / ((float)fDistanceToWall);
			int nCeiling = (int)nCeiling_f;
			int nFloor = ConScreenHeight - nCeiling;

			short nShade = ' ';
			short nShade2 = ' ';

			if (fDistanceToWall <= fDepth / 4.0f)
				nShade = 0x2588;
			else if (fDistanceToWall < fDepth / 3.5f)
				nShade = 0x2593;
			else if (fDistanceToWall < fDepth / 2.0f)
				nShade = 0x2592;
			else if (fDistanceToWall < fDepth / 1.5f)
				nShade = 0x2591;
			else
				nShade = ' ';

			for (int y = 0; y < ConScreenHeight; y++)
			{
				unsigned int index = (y * ConScreenWidth + x);

				if (y < nCeiling)
					screen[index] = ' ';
				else if (y > nCeiling && y < nFloor)
					screen[index] = nShade;
				else
				{
					float FlrDist = 1.0f - (((float)y - ConScreenHeight / 2.0f) / ((float)ConScreenHeight / 2.0f));

					if (FlrDist < 0.15)
						nShade2 = 'U';
					else if (FlrDist < 0.35)
						nShade2 = '8';
					else if (FlrDist < 0.55)
						nShade2 = 'o';
					else if (FlrDist < 0.75)
						nShade2 = ':';
					else if (FlrDist < 0.95)
						nShade2 = '.';
					else
						nShade2 = ' ';

					screen[index] = nShade2;
				}
			}
		}

		screen[ConScreenWidth * ConScreenHeight] = '\0';
		WriteConsoleOutputCharacter(hConsole, screen, ConScreenWidth * ConScreenHeight, { 0, 0 }, &dwBytesWritten);
	}

	/* free memory */
	delete[] screen;

	waitmessage("press a key to end program.");

	return 0;
}
